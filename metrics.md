Функция `insert_wallet_statistics` выполняет вставку статистических данных о кошельках в таблицу статистики на основе данных из таблицы балансов. Она рассчитывает различные метрики, связанные с балансами кошельков, и группирует их по категориям. Давайте разберем, что делает функция, и какие метрики она рассчитывает, по порядку.

---

### **1. Подготовка данных**
- **Входные параметры:**
  - `stamp`: Временная метка (дата и время), для которой рассчитывается статистика.
  - `smart_money_lb_usd`: Пороговое значение в USD, используемое для классификации кошельков как "умных денег".
  - `network_id`: Идентификатор сети, для которой рассчитывается статистика.

- **Преобразование временной метки:**
  - `timestamp = date_to_datetime(stamp)`: Преобразует входную временную метку в формат `datetime`.
  - Определяются временные интервалы:
    - `year = dt.timedelta(days=365)`: Год.
    - `month = dt.timedelta(days=30)`: Месяц.
    - `six_months = 6 * month`: Полгода.

---

### **2. Расчет балансов**
- **Баланс с учетом десятичных разрядов:**
  - `balance_with_decimals = CoinWalletBalance.balance / sa.func.power(10, CoinNetwork.decimals)`:
    - Баланс кошелька нормализуется с учетом количества десятичных разрядов (decimals) для корректного отображения суммы.

- **Баланс в USD:**
  - `balance_usd = balance_with_decimals * sa.func.coalesce(CoinPrice.price_usd, 0)`:
    - Рассчитывается баланс кошелька в USD на основе текущей цены монеты.

---

### **3. Общие столбцы для выборок**
- **`common_columns`**:
  - Список общих столбцов, которые используются в большинстве запросов:
    - `CoinWalletBalance.coin_id`: Идентификатор монеты.
    - `sa.func.count().label("cnt")`: Количество кошельков.
    - `sa.func.sum(balance_with_decimals).label("balance_summ")`: Суммарный баланс.

---

### **4. Расчет метрик**
Функция рассчитывает несколько метрик, группируя кошельки по различным критериям. Каждая метрика представлена в виде подзапроса, который затем объединяется в общий запрос.

#### **Метрика: Holders**
- **Описание:** Кошельки, которые являются EOA (Externally Owned Accounts) и не принадлежат централизованным биржам (CEX).
- **Условие:** `CoinWalletBalance.is_eoa_not_cex`.
- **Метрики:**
  - `holders`: Количество таких кошельков.
  - `holder_balance`: Суммарный баланс этих кошельков.

#### **Метрика: Hodlers**
- **Описание:** Кошельки, которые являются EOA, не принадлежат CEX, имеют баланс меньше `smart_money_lb_usd`, и у которых либо не было нулевых депозитов, либо последний нулевой депозит был более года назад.
- **Условия:**
  - `CoinWalletBalance.is_eoa_not_cex`.
  - `balance_usd < smart_money_lb_usd`.
  - `CoinWalletBalance.last_zero_deposit.is_(None) | (CoinWalletBalance.last_zero_deposit < timestamp - year)`.
- **Метрики:**
  - `hodlers_`: Количество таких кошельков.
  - `hodler_balance`: Суммарный баланс этих кошельков.

#### **Метрика: Cruisers**
- **Описание:** Кошельки, которые являются EOA, не принадлежат CEX, имеют баланс меньше `smart_money_lb_usd`, и у которых последний нулевой депозит был между 1 месяцем и 1 годом назад.
- **Условия:**
  - `CoinWalletBalance.is_eoa_not_cex`.
  - `balance_usd < smart_money_lb_usd`.
  - `timestamp - year <= CoinWalletBalance.last_zero_deposit`.
  - `CoinWalletBalance.last_zero_deposit < timestamp - month`.
- **Метрики:**
  - `cruisers`: Количество таких кошельков.
  - `cruiser_balance`: Суммарный баланс этих кошельков.

#### **Метрика: Traders**
- **Описание:** Кошельки, которые являются EOA, не принадлежат CEX, имеют баланс меньше `smart_money_lb_usd`, и у которых последний нулевой депозит был менее месяца назад.
- **Условия:**
  - `CoinWalletBalance.is_eoa_not_cex`.
  - `balance_usd < smart_money_lb_usd`.
  - `timestamp - month <= CoinWalletBalance.last_zero_deposit`.
- **Метрики:**
  - `traders`: Количество таких кошельков.
  - `trader_balance`: Суммарный баланс этих кошельков.

#### **Метрика: Smart Moneys**
- **Описание:** Кошельки, которые являются EOA, не принадлежат CEX, и имеют баланс больше или равный `smart_money_lb_usd`.
- **Условия:**
  - `CoinWalletBalance.is_eoa_not_cex`.
  - `balance_usd >= smart_money_lb_usd`.
- **Метрики:**
  - `smart_moneys`: Количество таких кошельков.
  - `smart_money_balance`: Суммарный баланс этих кошельков.

#### **Метрика: Circulating Supply**
- **Описание:** Общий баланс кошельков, которые обновлялись за последние 6 месяцев.
- **Условия:**
  - `CoinWalletBalance.updated_at.is_(None) | (CoinWalletBalance.updated_at >= timestamp - six_months)`.
- **Метрики:**
  - `circulating_supply`: Суммарный баланс этих кошельков.

#### **Метрика: CEXes**
- **Описание:** Кошельки, которые принадлежат централизованным биржам (CEX).
- **Условия:**
  - `CoinWalletBalance.is_cex`.
- **Метрики:**
  - `cexes`: Количество таких кошельков.
  - `cex_balance`: Суммарный баланс этих кошельков.

#### **Метрика: Smart Contracts**
- **Описание:** Кошельки, которые являются смарт-контрактами и не относятся к DEX или CEX.
- **Условия:**
  - `CoinWalletBalance.is_smart_contract_not_dex_not_cex`.
- **Метрики:**
  - `smart_contracts`: Количество таких кошельков.
  - `smart_contract_balance`: Суммарный баланс этих кошельков.

#### **Метрика: DEXes**
- **Описание:** Кошельки, которые принадлежат децентрализованным биржам (DEX).
- **Условия:**
  - `CoinWalletBalance.is_dex`.
- **Метрики:**
  - `dexes`: Количество таких кошельков.
  - `dex_balance`: Суммарный баланс этих кошельков.

---

### **5. Объединение данных**
- **`base_subq`:** Базовый подзапрос, который рассчитывает общий баланс (`total_supply`) для каждой монеты.
- **`subqueries`:** Все подзапросы для метрик объединяются с базовым подзапросом через `outerjoin`.
- **`stats`:** Итоговый запрос, который объединяет все метрики и возвращает их для каждой монеты.

---

### **6. Вставка данных**
- **`rows = res.fetchall()`:** Получение всех строк результата.
- **`return await self.insert_rows(CoinWalletStatistics.__table__, rows)`:** Вставка данных в таблицу `CoinWalletStatistics`.

---

### **Итог**
Функция `insert_wallet_statistics` рассчитывает и вставляет в таблицу статистики следующие метрики:
1. Holders.
2. Hodlers.
3. Cruisers.
4. Traders.
5. Smart Moneys.
6. Circulating Supply.
7. CEXes.
8. Smart Contracts.
9. DEXes.

Каждая метрика включает количество кошельков и их суммарный баланс, что позволяет анализировать распределение средств между различными категориями кошельков.

Ниже приведено подробное структурированное пояснение к данному файлу, в котором описывается логика вычисления и обновления рыночных метрик для монет и пулов, а также публикация этих данных в Kafka. Обратите внимание на следующие ключевые моменты:

---

## 1. Общая цель модуля `on_chain.py`

- **Расчёт метрик**: Файл предназначен для вычисления и обновления различных рыночных показателей («market data») на основе on-chain данных, таких как ликвидность, рыночная капитализация и объёмы торгов.
- **Агрегация и обновление**: Используя данные из таблиц (например, `OHLCV`, `CoinWalletStatistics`, `CoinPastPrice`, `PoolMarketData`), модуль агрегирует и обновляет значения в таблицах `CoinMarketData`, `PoolMarketData` и агрегированных данных для монет (`XCoinMarketDataAgg`).
- **Публикация данных**: После обновления данные публикуются в Kafka-топики для последующей обработки или передачи во внешние системы.

---

## 2. Вспомогательные функции и переменные

### 2.1. Функция `get_liquidity_subquery`

- **Назначение**: Создаёт подзапрос, вычисляющий суммарную ликвидность (в долларах США) для конкретной монеты.
- **Механизм**:
  - Выполняется выборка из таблицы `PoolMarketData`, где суммируются показатели `base_token_pooled_usd` и `quote_token_pooled_usd`.
  - Присоединяются таблицы `Pool` (для получения данных о пуле) и `CoinNetwork` (через переданный аргумент `coin_network` и атрибут `pool_token_address`), что позволяет соотнести данные с конкретной монетой.
  - Фильтрация происходит по заданной релевантности данных (`DataRelevance`) и сети (`network_id`).
  - Результаты группируются по идентификатору монеты.

### 2.2. Функция `get_all_time_liquidity_subquery`

- **Назначение**: Вычисляет «all-time» ликвидность для монет по всем пулам.
- **Механизм**:
  - Используется таблица `OHLCV` для получения первоначальных данных по ликвидности пула (с использованием резервов базового и котируемого токенов и их цен).
  - Применяются алиасы для таблиц `CoinNetwork` и `CoinPrice`, чтобы разделить данные для базового и котируемого токенов.
  - Функция `date_trunc` используется для агрегации по дням.
  - Первоначальные результаты по пулам объединяются (через `UNION`) для базового и котируемого токена, после чего агрегируются по `coin_id`.

### 2.3. Переменная `relevances`

- **Назначение**: Определяет соответствие между периодами (день, неделя, месяц и т.д.) и именами колонок, в которых будут храниться рассчитанные значения ликвидности (например, `"liquidity_usd_1d"`, `"liquidity_usd_7d"` и т.д.).

---

## 3. Класс `OnChainMarketDataDbSession`

Является расширением базового класса сессии для работы с базой данных и содержит методы для вычисления и обновления метрик.

### 3.1. Метод `update_coin_market_cap`

- **Цель**: Обновление рыночной капитализации монет.
- **Основные шаги**:
  - Определение последнего (максимального) временного штампа (`max_ts`) для записей в `CoinWalletStatistics`.
  - **Базовый подзапрос (`base_subquery`)**:
    - Выбираются поля: `coin_id`, `total_supply`, `circulating_supply`.
    - Вычисляются:
      - `market_cap_usd` как произведение `circulating_supply` на цену из `CoinPastPrice` (с фильтром по `DataRelevance.latest`).
      - `fully_diluted_market_cap_usd` как произведение `total_supply` на ту же цену.
  - **Подзапросы для расчёта изменения капитализации**:
    - Для каждого заданного интервала (например, день, неделя, месяц и т.д.) создаются подзапросы, которые получают исторические значения рыночной капитализации.
    - Затем для каждого интервала рассчитывается процентное изменение:  
      \[
      \text{change} = \frac{\text{текущая капитализация}}{\text{историческая капитализация (с обработкой NULL через nullified)}} - 1
      \]
  - **Объединение данных**:
    - Основной запрос объединяет базовые данные и рассчитанные изменения с помощью `outerjoin` по `coin_id`.
    - Результат записывается в таблицу `CoinMarketData` с опцией `OnConflict.UPDATE`, что означает обновление существующих записей.

### 3.2. Метод `update_coin_liquidity`

- **Цель**: Обновление показателей ликвидности монет.
- **Основные шаги**:
  - Создаются два подзапроса для получения ликвидности: один для базового токена, другой – для котируемого, с использованием функции `get_liquidity_subquery` с параметром `DataRelevance.latest`.
  - **Вычисление текущей ликвидности (`curr_liquidity_usd`)**:
    - Представляет собой сумму ликвидностей, полученных для базового и котируемого токенов, с использованием функции `zeroed` для обработки возможных `NULL` значений.
  - **Расчёт изменения ликвидности**:
    - Для каждого интервала из переменной `relevances` вычисляются исторические значения ликвидности (отдельно для базового и котируемого токена).
    - Производится деление текущей ликвидности на сумму исторических значений и вычитание единицы для получения изменения.
  - **Формирование итогового запроса**:
    - Выбираются `network_id`, `coin_id`, текущее значение ликвидности и рассчитанные изменения.
    - Данные связываются через `outerjoin` с подзапросами и записываются в `CoinMarketData` с опцией обновления при конфликте.

### 3.3. Метод `update_pool_market_data`

- **Цель**: Обновление рыночных данных пулов (например, ликвидности пула, объёма торгов за 24 часа, цен).
- **Основные шаги**:
  - Получение максимального временного штампа (`tx_max`) из таблицы `OHLCV`. Если данных нет, метод возвращает 0.
  - Определение верхней границы временного интервала (`ts_upper_bound`) с использованием функции `relevance_to_intervals`, которая задаёт временной дельту для каждого уровня релевантности.
  - **Подзапросы**:
    - `liq_subq` – получает данные ликвидности с учётом временного ограничения.
    - `vol_24h_subq` – получает объём торгов за последние 24 часа.
    - `price_subq` – получает данные по ценам.
  - Использование алиасов для разделения данных по базовому и котируемому токенам (например, `base_coin`, `quote_coin`).
  - **Нормализация значений**:
    - Деление значений резервов на степень 10, вычисляемую по количеству десятичных знаков (`decimals`), для корректного преобразования единиц.
  - **Расчёт ликвидности пула**:
    - Вычисляется как минимальное значение (с помощью `sa.func.least`) между ликвидностью, рассчитанной на основе базового и котируемого токенов.
  - **Расчёт объёма торгов**:
    - Аналогично вычисляется с использованием цен и объёмов торгов.
  - **Финальный агрегированный запрос**:
    - Запрос выбирает набор полей: данные релевантности, адрес пула, нормализованные объемы токенов, рассчитанные ликвидности (и их USD-эквиваленты), объемы торгов и цены.
    - Данные записываются в таблицу `PoolMarketData` с опцией обновления при конфликте.

---

## 4. Класс `OnChainMarketDataUpdater`

Этот класс является высокоуровневым обновлятором, который использует методы из `OnChainMarketDataDbSession` и добавляет логику публикации данных в Kafka. Он также наследуется от `DataUpdater`.

### 4.1. Обновление данных

- **Метод `update_pool_market_data`**:
  - Принимает параметры `network_id` и `relevance`.
  - Получает идентификатор соединения с базой (`pgpid`) для логирования.
  - Вызывает метод обновления пулов из сессии (`db_session.update_pool_market_data`), фиксирует изменения через `commit` и возвращает количество обновлённых записей.
  
- **Метод `update_coin_market_data`**:
  - Вызывает последовательно методы `update_coin_liquidity` и `update_coin_market_cap`.
  - После выполнения коммитит изменения и возвращает кортеж с количеством обновлённых записей по ликвидности и капитализации.

### 4.2. Публикация данных в Kafka

- **Метод `publish_pool_market_data`**:
  - Определяет Kafka-топик на основе настроек (режим работы, сеть).
  - Извлекает из базы данные из таблицы `PoolMarketData` по заданной сети.
  - Для каждой записи сериализует данные (метод `to_json`) и отправляет их в Kafka-топик.
  
- **Метод `publish_coin_market_data`**:
  - Аналогично предыдущему, но работает с данными из таблицы `CoinMarketData`.

### 4.3. Агрегация данных для монет

- **Метод `update_x_coin_market_data_agg`**:
  - Аггрегирует данные из таблицы `XCoinMarketData` и записывает результат в `XCoinMarketDataAgg`.
  - Выполняется группировка по `coin_id` с применением:
    - Функции `first` для выбора первого значения из определённых колонок (например, цены).
    - Агрегационной суммы для некоторых колонок (например, ликвидности, капитализации, предложений).
    - Вычислением прироста (gain) для полей, используя специальную функцию `gained_sum`, которая рассчитывает процентное изменение по формуле:  
      $ \text{gain} = \frac{\text{sum(current)}}{\text{sum(old)}} - 1$
      где `sum(old)` вычисляется с учётом коррекции через деление на (1 + gain) и обработкой деления на ноль с использованием `nullif`.
  - Перед вставкой таблица `XCoinMarketDataAgg` очищается (truncate), затем данные вставляются через метод `insert_rows_from_select`, после чего выполняется коммит.

---

## 5. Использование декораторов и асинхронного выполнения

- **Декораторы `@with_db_session` и `@default_db_session_maker`**:
  - Обеспечивают создание и управление сессией базы данных, автоматически передавая объект сессии в методы и выполняя коммиты.
- **Декоратор `@with_kafka_producer`**:
  - Гарантирует корректное получение и управление асинхронным Kafka-производителем для отправки сообщений.
- **Асинхронность**:
  - Все методы объявлены с ключевым словом `async`, что позволяет выполнять операции ввода-вывода (запросы к БД, отправку сообщений в Kafka) без блокировки.

---

## 6. Интеграция с конфигурацией и настройками

- Использование глобального объекта `config` позволяет задавать:
  - **Сеть**: Определяется через `config["evm_node"]["network"]`, что позволяет выбирать соответствующий `NetworkId`.
  - **Режим работы**: На основе параметра `config["mode"]` выбирается префикс топика для Kafka (`"rx"` для production или `"rxs"` для остальных режимов).

---

## 7. Особенности работы с SQLAlchemy

- **Использование Core и ORM**:
  - Запросы строятся с использованием методов SQLAlchemy (`sa.select`, `sa.join`, `sa.outerjoin` и т.д.) и выполняются асинхронно.
- **Подзапросы и CTE**:
  - Для сложных вычислений используются подзапросы и выражения с использованием CTE (Common Table Expression) – например, в функции `get_all_time_liquidity_subquery`.
- **Агрегатные функции**:
  - Применяются функции `sum`, `first`, `least`, `power` для выполнения математических операций и агрегирования данных.
- **Обработка NULL-значений**:
  - Функции `nullified` и `zeroed` используются для корректной обработки значений при арифметических операциях (например, чтобы избежать деления на ноль или работы с `NULL`).

---

## 8. Итог

Данный файл организует полный цикл обработки on-chain рыночных данных:
- **Сбор и агрегация данных** из различных источников (цен, резервов, статистик по монетам и пулам).
- **Вычисление метрик** (рыночной капитализации, ликвидности, объемов торгов) с учётом исторических изменений.
- **Обновление базы данных** с поддержкой обновления при конфликте.
- **Публикация результатов** в Kafka для дальнейшей обработки.

Такой подход позволяет централизованно рассчитывать и распространять рыночные метрики, что является важной составляющей инфраструктуры для аналитики и дальнейшего использования данных в графических интерфейсах или других системах.

---

Это структурированное пояснение охватывает основные аспекты и важные моменты работы кода.